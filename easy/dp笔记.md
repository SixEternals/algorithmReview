##### 学习 dp 动态规划之前的须知

对于没接触过的人 dp 很难想到 比起其他模板比如说二分 大整数加减乘除...这些可以现场推理的不同 dp 更多的像是一种经验 你没接触过就很难想到思路 甚至看了题解都懵逼半天 甚至可能刚掌握了几个简单的 dp 的小问题 然后在听了一个比较复杂的 dp 讲解后过几个月发现写不出来了

∴dp 像是一种经验谈 几乎就是没见过就写不出 多练，刚学时限制十分钟内想不出就直接看解析吧

# 背包问题

[芜！完美的解释！](https://blog.csdn.net/raelum/article/details/128996521)
一般输入的数据量为 1000 左右 可以考虑用 dp

## 01 背包

问题描述：N 件物品 背包容量为 V 每件只用一次 然后输入每件物品的体积与价值
从**当前背包容量从 1 递增到 V**和**从 1 号物品递增到 N 号** 入手
假设 N=4,V=5
得到表格

```cpp
填写顺序:二维数组遍历 从左到右 从上到下
\ V
N 1  2  3  4  5
1 O
2
3
4
我们默认dp[][]是静态区分数组 故其内部全0 就省的初始化全dp[i][0]=dp[0][i]=0了
在第一个`O`中填入2 表示当前背包容量为1 能选择一号物品时得到的最大价值

\ V
N 1  2  3  4  5
1
2
3
4    O
而当填入该大O位置时 表示当前背包容量为2时 而且可选物品为 1 2 3 4 物品
具体怎么填不写出来了 很容易推 链接写的也很明白 我只是写了二周目复习时的要点
```

代码

```cpp
for(int i = 1; i <= N; ++i)
    for(int j = 1; j <= V; ++j)
        if(j >= w[i]) // 选第i物品的前提下
            dp[i][j] = max(dp[i - 1][j], dp[i-1][j - w[i]] + v[i]); // max内意为只选了前i-1件的价格 与 选了前i件再加上这件 比较谁更值钱
        else
            dp[i][j] = dp[i-1][j]; // 本来就不够位置放第i件物品 就直接取前i-1件物品的最优选择
```

使用滚动数组优化
要点：第二层循环倒着来
原因：
我们二维 01 背包是的 dp[i]从 dp[i-1]的来;而 dp[i-1]由 dp[i-2]的来...
以此类推 发现我们更新 dp[i]的时候和 dp[i-2]没有**直接**关系 那么可以将其优化为**一维背包**
则情况 1 不选择第 i 件物品时 dp[i-1][j] 相当于 dp[i]被更新前的旧值 即写的时候不写 dp[i-1]而是写 dp[i]
则情况 2 选择时 dp[i-1]j - w[i]] + v[i] 相当于 d[i]吗？

这时有个矛盾 当我们按照二维数组写法 让第一层是正序递增 第二层也是正序递增时会出现一维数组从左往右地更新
相当于 dp[i][j] = dp[i-1][j] 由于我们的二维数组天生就能保存旧值 指 dp[i-1][j]
但是一维数组少了一维 就没有这个特性了 旧值就是它自己 dp[i]
如果此时还是在第二层正序更新的话那就会覆盖一维数组 dp[i]的旧值 -> **解决方法:倒序遍历第二层**

[代码实现回去翻->](./14dp.cpp)

## 完全背包

题目描述：N 件物品 背包容量 V 每件能用无数次
得益于无穷多的物品 现在就多了很多种选择 即可以反复选择同一件高价值又低重量的物品 -> 可选为 k 件 其中 k 范围为( 0 <= k <= V/w[i] )
就在原来二维背包的代码上有所修改：多了一层 k 循环

```cpp
for(int i = 1; i <= N; ++i)
    for(int j = 1; j <= V; ++j)
        for(int k = 0; k * w[i] <= j; ++k)
            dp[i][j] = max(dp[i][j], dp[i - 1][j - k * w[i]] + k * v[i]);
```

[对完美的背包的，芜湖！完美的解释](https://www.acwing.com/solution/content/180720/)

```cpp
    f[i][j]  { = 集合 g[i][j]
   /=状态表示 { = 属性 (最大值||最小值||数量，这个具体要看题目求什么)
dp
   \=状态计算

这部分可以看线性dp的视频https://www.acwing.com/video/2294/
```

对`dp[i][j] = max(dp[i][j], dp[i - 1][j - k * w[i]] + k * v[i]);`的解释:
最开始 k=0 而且 j/w[i] == 0 时 由于 dp[i][j]是静态全局变量所以本来是 0 由于 max 他会令 dp[i][j]=dp[i-1][j-0] + 0
然后进行一个最大值的求，这样写 因为我们比 01 背包多了一层 k 循环 所以可以用 k 来控制‘不选物品 i’ 相当于 01 背包的 dp[i][j]=max(dp[i-1][j],dp[i-1][j-w]+v)

## 多重背包

题目描述：N 件物品 背包容量 V 每件的数量各不同

# 线性 dp

[一个视频解君愁](https://www.acwing.com/video/2294/)

## 数字三角形

看图片！！
[私密买赛写的时候大拇指受伤了握不住笔写出了丑出天际的笔记](./11pictures/线性dp状态集合怎么求.png)

补充一点 从三角形的下层开始往上迭代会省下写边界判断的功夫
原因：

```

若从上往下 发现只有E可以走到H I两条路径 而其他点只能走一个点 这时候就要添加边界判断了
若从下往上 发现每两点分别有两条路指向同一个点(顶点A除外) 这样就省了边界判断
再看我上面的笔记图片 看看四条路径的颜色都是不一样的 再看看旁边的注释就行
```

代码

```cpp

```

## 最长上升子序列 longest Increasing Sequence

[题目链接](https://www.acwing.com/problem/content/897/)
题目描述

```
给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。

输入格式
第一行包含整数 N。
第二行包含 N 个整数，表示完整序列。

输出格式
输出一个整数，表示最大长度。

数据范围
1≤N≤1000，−109≤数列中的数≤109
```

### 朴素做法

注意点：
① 时间复杂度为 O(n^2) 数据一旦超过 1w 就会爆了 所以才会有下面的优化版本
②"数值严格单调递增子序列"≠"单调连续递增"，即题目要求即使不连续的递增子序列也算数

根据 y 总的一个思路模板

```
               / 集合 -> 对于本题就是到第i个元素为止的所有递增排列
    /  状态表示-  属性(有max min 个数 三种) 本题要求'最长' 即max
DP  |          \ 使用几维数组就能够表示出所有状态 从低维开始考虑 越低越不会OT
    \  状态计算 ？
```

关于用几维：一维即可 因为输入只有一个一维数组啊
关于状态计算： 可以用

(以下写完感觉解释了一坨 不如看 Y 总视频)

举例

```
输入
7
3 1 2 1 8 5 6
则用a[]来存入数据 用dp来存递增子序列的最长长度
idx  1 2 3 4 5 6 7  下标从1开始
a[i] 3 1 2 1 8 5 6  把原始数据存入a[]
dp   1 1 2 2 3 3 4  记录到i为止的最长递增字串长度
```

然后判断也很简单 基于 Y 总在线性 dp 的第一个解析视频里所讲

```
    A
   B C
  D E F
 G H I J K
L I M N O P

从
 D E F
  /\
 G H I J K
/\/
L I M N O P
```

我们 dp 本来就是从一系列路线/选择/集合中的最优的唯一选择
即假设上图中从最底层到 E 点路径有(L-G-E 总权值为 10) (I-G-E 总权值为 6) (I-H-E 总权值为 1) 这三条路径组成到达 E 的路径**集合**
而 dp[E]必然等于 10 即 LGE 线 在集合中的所有值都被 max 收缩为 LGE 线 就等同于 dp 存的永远是最优答案
即不用考虑集合中所有路线怎么走 我们只需要最大值

引出最长上升子序列的一句关键代码
`dp[i] = max(dp[i], dp[j] + a[i])`

代码

```cpp
for(int i = 1; i <= n ; ++i){
    dp[i] = 1;
    for(int j = 1; j < i; ++i)
        if(a[i] > a[j])
            dp[i] = max(dp[i], dp[j] + 1);
}
```

### 优化版本

优化思路：
旧版：

```
对于a[i] 需要枚举a[1]...a[i-1]这么多个元素 其中还有多余的枚举
对于子序列长度一致的元素就没有必要全部录入了 留下a[i]中最小那个就行
举例   √   √   √   √
index  1 2 3 4 5 6 7
a[]    3 1 2 1 8 5 6
dp     1 1 2 2 3 3 4

可以dp中有重复的长度1 2 3
由上可知我们只需要保存下标为1 3 5 7就可以了
```

优化版：
用一个数组 q[]来存筛选状态 筛选标准如上
然后可以用**二分查找**来快速找到最佳已知状态
