# 背包问题

[芜！完美的解释！](https://blog.csdn.net/raelum/article/details/128996521)
一般输入的数据量为 1000 左右 可以考虑用 dp

## 01 背包

问题描述：N 件物品 背包容量为 V 每件只用一次 然后输入每件物品的体积与价值
从**当前背包容量从 1 递增到 V**和**从 1 号物品递增到 N 号** 入手
假设 N=4,V=5
得到表格

```cpp
填写顺序:二维数组遍历 从左到右 从上到下
\ V
N 1  2  3  4  5
1 O
2
3
4
我们默认dp[][]是静态区分数组 故其内部全0 就省的初始化全dp[i][0]=dp[0][i]=0了
在第一个`O`中填入2 表示当前背包容量为1 能选择一号物品时得到的最大价值

\ V
N 1  2  3  4  5
1
2
3
4    O
而当填入该大O位置时 表示当前背包容量为2时 而且可选物品为 1 2 3 4 物品
具体怎么填不写出来了 很容易推 链接写的也很明白 我只是写了二周目复习时的要点
```

代码

```cpp
for(int i = 1; i <= N; ++i)
    for(int j = 1; j <= V; ++j)
        if(j >= w[i]) // 选第i物品的前提下
            dp[i][j] = max(dp[i - 1][j], dp[i-1][j - w[i]] + v[i]); // max内意为只选了前i-1件的价格 与 选了前i件再加上这件 比较谁更值钱
        else
            dp[i][j] = dp[i-1][j]; // 本来就不够位置放第i件物品 就直接取前i-1件物品的最优选择
```

使用滚动数组优化
要点：第二层循环倒着来
原因：
我们二维 01 背包是的 dp[i]从 dp[i-1]的来;而 dp[i-1]由 dp[i-2]的来...
以此类推 发现我们更新 dp[i]的时候和 dp[i-2]没有**直接**关系 那么可以将其优化为**一维背包**
则情况 1 不选择第 i 件物品时 dp[i-1][j] 相当于 dp[i]被更新前的旧值 即写的时候不写 dp[i-1]而是写 dp[i]
则情况 2 选择时 dp[i-1]j - w[i]] + v[i] 相当于 d[i]吗？

这时有个矛盾 当我们按照二维数组写法 让第一层是正序递增 第二层也是正序递增时会出现一维数组从左往右地更新
相当于 dp[i][j] = dp[i-1][j] 由于我们的二维数组天生就能保存旧值 指 dp[i-1][j]
但是一维数组少了一维 就没有这个特性了 旧值就是它自己 dp[i]
如果此时还是在第二层正序更新的话那就会覆盖一维数组 dp[i]的旧值 -> **解决方法:倒序遍历第二层**

[代码实现回去翻->](./14dp.cpp)

## 完全背包

题目描述：N 件物品 背包容量 V 每件能用无数次
得益于无穷多的物品 现在就多了很多种选择 即可以反复选择同一件高价值又低重量的物品 -> 可选为 k 件 其中 k 范围为( 0 <= k <= V/w[i] )
就在原来二维背包的代码上有所修改：多了一层 k 循环

```cpp
for(int i = 1; i <= N; ++i)
    for(int j = 1; j <= V; ++j)
        for(int k = 0; k * w[i] <= j; ++k)
            dp[i][j] = max(dp[i][j], dp[i - 1][j - k * w[i]] + k * v[i]);
```

[对完美的背包的，芜湖！完美的解释](https://www.acwing.com/solution/content/180720/)

```cpp
    f[i][j]  { = 集合 g[i][j]
   /=状态表示 { = 属性 (最大值||最小值||数量，这个具体要看题目求什么)
dp
   \=状态计算

这部分可以看线性dp的视频https://www.acwing.com/video/2294/
```

对`dp[i][j] = max(dp[i][j], dp[i - 1][j - k * w[i]] + k * v[i]);`的解释:
最开始 k=0 而且 j/w[i] == 0 时 由于 dp[i][j]是静态全局变量所以本来是 0 由于 max 他会令 dp[i][j]=dp[i-1][j-0] + 0
然后进行一个最大值的求，这样写 因为我们比 01 背包多了一层 k 循环 所以可以用 k 来控制‘不选物品 i’ 相当于 01 背包的 dp[i][j]=max(dp[i-1][j],dp[i-1][j-w]+v)

## 多重背包

题目描述：N 件物品 背包容量 V 每件的数量各不同

# 线性 dp

[一个视频解君愁](https://www.acwing.com/video/2294/)

## 数字三角形

看图片！！
[私密买赛写的时候大拇指受伤了握不住笔写出了丑出天际的笔记](./11pictures/线性dp状态集合怎么求.png)

补充一点 从三角形的下层开始往上迭代会省下写边界判断的功夫
原因：

```

若从上往下 发现只有E可以走到H I两条路径 而其他点只能走一个点 这时候就要添加边界判断了
若从下往上 发现每两点分别有两条路指向同一个点(顶点A除外) 这样就省了边界判断
再看我上面的笔记图片 看看四条路径的颜色都是不一样的 再看看旁边的注释就行
```

代码

```cpp

```
